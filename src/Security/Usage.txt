
// flowerbox this
---------------------------------------------
    Instantiating Security & Encryption
---------------------------------------------

ToDo:
// add some context for usage
// check on composer updates/ usage for autoloading

Notes:
Lazy-Loaded Services (Load on Demand)
php// Only loaded when fonts are used
class FontManager {
    // Functions: _putfonts, _puttruetypeunicode, getFontsList, font buffers
}

// Only loaded when images are processed
class ImageProcessor {
    // Functions: _putimages, ImagePngAlpha, getGDgamma, image buffers
}

// Only loaded when HTML content is processed
class HTMLProcessor {
    // Functions: getHtmlDomArray, openHTMLTagHandler, CSS methods
}

// Only loaded when SVG is processed
class SVGProcessor {
    // Functions: startSVGElementHandler, SVGPath, setSVGStyles
}

// Only loaded when encryption is needed
class SecurityManager {
    // Functions: _putencryption, _Uvalue, _generateencryptionkey
}

// Only loaded when advanced features are used
class AdvancedFeatures {
    // Functions: _putbookmarks, _addfield, _putjavascript
}
🚀 Performance Optimization Strategy
1. Lazy Loading Implementation
phpclass TCPDF {
    private ?HTMLProcessor $htmlProcessor = null;
    private ?SVGProcessor $svgProcessor = null;
    
    private function getHTMLProcessor(): HTMLProcessor {
        return $this->htmlProcessor ??= new HTMLProcessor($this->core);
    }
    
    public function writeHTML($html) {
        return $this->getHTMLProcessor()->process($html);
    }
}
2. Service Locator Pattern
phpclass ServiceManager {
    private static array $services = [];
    
    public static function get(string $service): object {
        return self::$services[$service] ??= new $service();
    }
}
3. Interface-Based Design
phpinterface RendererInterface {
    public function render(array $data): string;
}

class HTMLRenderer implements RendererInterface { /* ... */ }
class SVGRenderer implements RendererInterface { /* ... */ }
⚡ Performance Impact Analysis
Memory Usage

Before: ~2-5MB for entire class loaded at once
After: ~500KB base + services loaded on demand
Savings: 60-80% memory reduction for simple PDF operations

Load Time

Before: Parse 25K+ lines on every instantiation
After: Parse ~3K lines base + load services as needed
Impact: 70-85% faster initial load

Execution Speed

Critical path: Keep frequently used functions in core classes
Lazy loading: 0.1-0.5ms overhead per service (negligible)
Autoloading: Modern PHP opcache eliminates file I/O penalties

🔄 Implementation Strategy
Phase 1: Extract Non-Critical Services (Low Risk)

SVGProcessor - rarely used, self-contained
SecurityManager - only used with encryption
AdvancedFeatures - bookmarks, forms, JS

Phase 2: Extract Heavy Processors (Medium Risk)

HTMLProcessor - complex but well-defined interface
FontManager - many internal dependencies to resolve
ImageProcessor - moderate complexity

Phase 3: Optimize Core (High Risk)

Split ContentRenderer if still too large
Create specialized rendering strategies
Optimize buffer management

🛡️ Risk Mitigation
Maintain Backward Compatibility
phpclass TCPDF {
    // Keep all original public methods as facades
    public function writeHTML($html) {
        return $this->getHTMLProcessor()->writeHTML($html);
    }
}
Performance Testing

Benchmark before/after with realistic workloads
Test memory usage with large documents
Measure autoloading overhead

Gradual Migration

Start with least-used services (SVG, Security)
Test thoroughly in staging environment
Monitor production performance metrics